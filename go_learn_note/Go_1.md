# Golang learn note ____ 1

### ***pyke elysia***

## 并发，并行，同步，异步

并发、并行，是逻辑结构的设计模式。

同步、异步，是逻辑调用方式。

串行是同步的一种实现，就是没有并发，所有任务一个一个执行完成。

并发、并行是异步的 2 种实现方式。

**并发**

*并发*是指程序**同时段**执行多个任务的能力，当程序执行这些任务时，任务完成的先后顺序并无明确的先后顺序，但可以明确的是这些任务在同一时间段内被同时执行，如果是单核处理器，则多任务会交替执行。也就是说在并发程序中任务A和任务B在多核处理器下可以同时执行，但是当任务同时执行时，我们一般称之为并行。

**并行**

*并行*是指程序**同时**执行多个任务的能力，与*并发*相似，完成任务的顺序无固定，但明确多个任务是同时被执行而非*并发*的交替执行。只能在多核处理器上实现。

**同步**

同步是指多个任务执行，在所有任务全部执行结束后，才算做任务完成。如任务A，B两个同步任务，当A任务执行结束后，若任务B仍在执行，任务A则处于未完成状态。

**异步**

异步是指多个任务执行，不需要等待所有任务执行完毕，只需对应的任务自己执行完毕即算作任务完成。如任务A，B两个异步任务，当A任务执行结束后，即使任务B仍在执行，任务A也是结束状态。

#### 笔者使用异步编写程序时遇到的问题

如下面这段 `JavaSrcipt` 代码

```JavaScript
function getReminder() { 
    let opt = true; 
    while(opt){ 
        // 一个具有async修饰的网络请求函数
        getReminderFromBack(num).then((data) => { 
            //do something;
            opt = false;
        }) 
    } 
}
```

已知上述程序在实际运行中进入死循环，试分析原因。

AI（来自Copilot in Edge）回答：

你的 `getReminder` 函数进入了“死循环”的原因，其实和 `JavaScript` 中的异步执行逻辑有关。让我们来拆解一下：

😵 原因解析：`while(opt)` 造成无限循环
`getReminderFromBack(num)` 是一个异步操作（返回 `Promise`）。

`while(opt)` 是同步执行的。它不会等待 `then(...)` 里面的逻辑完成。

所以 `while(opt)` 会迅速执行无数次，疯狂调用 `getReminderFromBack(num)`，导致逻辑无法正常中断，页面可能会卡住或者崩溃。

这不是传统意义上的死循环，而是“同步代码在等待异步操作完成之前已经失控地进入循环”。

## `Golang`中实现并发

- 写在前面：go中调度器试给予GMP模型来实现处理多线程任务的。其中G就是下面首先讲到的`goroutine`，M为系统线程，P为逻辑处理器。这些在一些涉及到深层代码生成逻辑时会有用到，但一般不会有人指出这其中的GMP分别是什么。

#### goroutine

在 go语言中提供了 `goroutine` 来实现轻量化多线程并发处理多任务。

通过 go语言中的关键字 `go` 加对应的函数名与需要的参数表（如下）即可开出一个新的 `goroutine` 。

```go
go 函数名(参数表)

go f(x, y, z)
```

如下例子：

```go
func sayHello() {
    for i := 0; i < 5; i++ {
        fmt.Println("Hello")
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    go sayHello() // 启动 Goroutine
    for i := 0; i < 5; i++ {
        fmt.Println("Main")
        time.Sleep(100 * time.Millisecond)
    }
}
```

运行结果：可以看到`Main`和`Hello`交替出现并无固定顺序。

#### 通道（Channel）

通道（Channel）是用于 Goroutine 之间的数据传递。

通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。

使用 make 函数创建一个 channel，使用 <- 操作符发送和接收数据。如果未指定方向，则为双向通道。

```go
ch <- v    // 把 v 发送到通道 ch
v := <-ch  // 从 ch 接收数据
           // 并把值赋给 v
```

声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建：

```go
ch := make(chan int)
```

#

***创建于2025/7/13***